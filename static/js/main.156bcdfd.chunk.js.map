{"version":3,"sources":["components/card-list/card-list.component.jsx","components/search-box/search-box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["CardList","props","SearchBox","placeholder","handleChange","className","type","onChange","App","onSearchChange","event","setState","searchField","target","value","state","monsters","fetch","then","response","json","users","this","filteredMonsters","filter","monster","name","toLowerCase","includes","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"6UAKaA,G,YAAW,SAAAC,MCUXC,G,YAAY,SAAC,GAAD,IAAEC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,aAAf,OACrB,2BACIC,UAAU,SACVC,KAAK,SACLH,YAAaA,EACbI,SAAUH,MCgGHI,E,kDA/Eb,aAAe,IAAD,8BACZ,gBAyCHC,eAAiB,SAAAC,GACd,EAAKC,SAAS,CAACC,YAAaF,EAAMG,OAAOC,SAxCzC,EAAKC,MAAQ,CACXC,SAAU,GACVJ,YAAa,IALH,E,gEA+BO,IAAD,OAClBK,MAAM,8CACHC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKV,SAAS,CAAEK,SAAUK,S,+BAYpC,MAE2BC,KAAKP,MAA/BC,EAFD,EAECA,SAAUJ,EAFX,EAEWA,YAIZW,EAAmBP,EAASQ,QAAO,SAAAC,GAAO,OAC9CA,EAAQC,KAAKC,cAAcC,SAAShB,EAAYe,kBAElD,OACE,yBAAKtB,UAAU,OAWb,gDACA,kBAAC,EAAD,CACEI,eAAgBa,KAAKb,eACrBN,YAAY,oBAEd,kBAAC,EAAD,CAAUa,SAAUO,S,GAzEVM,aCxBEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBxB,MAAK,SAAAyB,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.156bcdfd.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Card } from '../card/card.component';\r\nimport './card-list.styles.css';\r\n\r\n\r\nexport const CardList = props => (\r\n    //console.log(props);\r\n    <div className='card-list'>\r\n        {props.monsters.map(monster => (\r\n            <Card key={monster.id} monster={monster} />\r\n        ))}  \r\n    </div>\r\n);","import React from 'react';\r\nimport './search-box.styles.css';\r\n\r\n/*\r\nfunctional components, unlike class components such as App.js component,\r\nthey don't have access to state b/c they don't have access to constructor(),\r\nwhich is a class method on Component that we import from 'react' that we\r\nextend our class from. \r\nfunctional components don't also have lifecycle methods. They don't have\r\ninternal state and lifecycle methods b/c we don't always use these.\r\nSometimes all we want to do is render some HTML. That is what a functional\r\ncomponent really is. A functional component is just something that gets some\r\nprops and returns some HTML. If you don't think you need internal state nor\r\naccess a lifecycle methods, use functional components.\r\n*/\r\nexport const SearchBox = ({placeholder, handleChange}) => (\r\n    <input \r\n        className='search'\r\n        type=\"search\"\r\n        placeholder={placeholder} //'search monsters'\r\n        onChange={handleChange}\r\n        /*{e => this.setState({ searchField: e.target.value }\r\n          ,() => console.log(this.state))}\r\n        */\r\n        >\r\n    </input>\r\n)","//import React from 'react';\nimport React, { Component } from 'react';\n//import logo from './logo.svg';\nimport { CardList } from './components/card-list/card-list.component';\nimport './App.css';\nimport { SearchBox } from './components/search-box/search-box.component';\n\n//let's convert this function to a class since we've more\n//functionality with class than function. For that we need to\n//import Component. By using class we get access to the 'state'\n//object from the Component class. this.state property now exists\n//on our class App and we can set it to something. \n//Another function that we get access to is setState()\n/*\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n}\n*/\n\nclass App extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      monsters: [],\n      searchField: ''\n    };\n\n    /*\n    .bind() is a method on any function that returns a new function\n    where the context of 'this' is set to whatever we passed to it.\n    Here we're setting the context of the 'this' keyword inside of\n    handleChange() to the 'this' keyword inside of this constructor(),\n    which is the Component that we're extending the App class from\n    But this is a very verbose way of writing code b/c that means for\n    every new class method we write, we've to bind() it. We don't have\n    to do that. We can leverage ES6 arrow functions and unique \n    charactersitics about them that allows them to set the context of\n    'this' in whatever it was that declared it in the first place. What\n    do we mean by this? Arrow functions automatically allow you to set\n    the 'this' keyword to the context where the arrow function itself\n    is defined in the first place. They automatically get what is called\n    lexical scoping.\n    */\n\n    //this.handleChange = this.handleChange.bind(this);\n  }\n\n  //componentDidMount is a lifecycle method that gets called when\n  //React puts our component on the page (when it renders on the DOM\n  //for the first time)\n  componentDidMount() {\n    fetch('https://jsonplaceholder.typicode.com/users')\n      .then(response => response.json())\n      .then(users => this.setState({ monsters: users }));\n  }\n\n  /*\n  handleChange(e) {\n    this.setState({searchField: e.target.value});\n  }\n  */\n onSearchChange = event => {\n    this.setState({searchField: event.target.value});\n  }\n\n  render() {\n    //destructuring\n    const { monsters, searchField } = this.state;\n    //the above is the same as the below two\n    //const monsters = this.state.monsters;\n    //const searchField = this.state.searchField;\n    const filteredMonsters = monsters.filter(monster =>\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n      )\n    return (\n      <div className=\"App\">\n        {/*anything we put here (in CardList here) will\n            be children of CardList (our component)*/}\n        {/*move this to card-list*/}\n        {/* \n        <CardList name=\"Eli\">\n          {this.state.monsters.map(monster => (\n            <h1 key={monster.id}> {monster.name}</h1>\n          ))}\n        </CardList>\n        */}\n        <h1>Monsters Rolodex</h1>\n        <SearchBox \n          onSearchChange={this.onSearchChange} \n          placeholder=\"search monsters\" \n        />\n        <CardList monsters={filteredMonsters} />\n      </div>\n    );\n  }\n    \n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}